/**

 * BACKEND: Script para manejar lecturas del PZEM (escritura) y visualización Web (lectura).

 * Deploy: Desplegar como Aplicación Web (Anyone, even anonymous) o con la seguridad que requieras.

 */



function doGet(e) {

  // Si viene colsToQuery es una petición de lectura (frontend).

  if (e.parameter && e.parameter.colsToQuery) {

    return handleRead(e);

  } else {

    // Si no, considerar como escritura simple (puede venir del ESP32 con parámetros).

    return handleWrite(e);

  }

}



// ----------------- Escritura (ESP32 u otro) -----------------

function handleWrite(e) {

  try {

    var ss = SpreadsheetApp.getActiveSpreadsheet();

    var sheet = ss.getSheetByName("LECTURAS PZEM");

   

    if (!sheet) {

      sheet = ss.insertSheet("LECTURAS PZEM");

      var headers = [

        "Fecha/Hora",

        "V_A","V_B","V_C",

        "I_A","I_B","I_C",

        "F_A","F_B","F_C",

        "P_Act_A","P_Act_B","P_Act_C",

        "P_Rea_A","P_Rea_B","P_Rea_C",

        "P_App_A","P_App_B","P_App_C",

        "FP_A","FP_B","FP_C",

        "P_Total","Q_Total","S_Total","FP_Total",

        "E_Act_Total","E_Rea_Total","E_App_Total"

      ];

      sheet.appendRow(headers);

      sheet.getRange(1,1,1,headers.length).setFontWeight("bold").setBackground("#c9daf8");

    }



    var p = e.parameter || {};

    var getVal = function(key) {

      if (p[key] === undefined || p[key] === null || p[key] === "") return 0;

      var v = Number(p[key]);

      return isNaN(v) ? p[key] : v;

    };



    var row = [ new Date() ];

    // En el frontend/ESP32 usa los nombres de parámetro que tu firmware envía.

    // Ejemplo de keys asumidas: vA,vB,vC,cA,cB,cC,fA,fB,fC,pActA,pActB,pActC,pReaA,pReaB,pReaC,pAppA,pAppB,pAppC,pfA,pfB,pfC,Ptotal,Qtotal,Stotal,PFtotal,Eact,Erea,Eapp

    row.push(getVal('vA'), getVal('vB'), getVal('vC'));

    row.push(getVal('cA'), getVal('cB'), getVal('cC'));

    row.push(getVal('fA'), getVal('fB'), getVal('fC'));

    row.push(getVal('pActA'), getVal('pActB'), getVal('pActC'));

    row.push(getVal('pReaA'), getVal('pReaB'), getVal('pReaC'));

    row.push(getVal('pAppA'), getVal('pAppB'), getVal('pAppC'));

    row.push(getVal('pfA'), getVal('pfB'), getVal('pfC'));

    row.push(getVal('Ptotal'), getVal('Qtotal'), getVal('Stotal'), getVal('PFtotal'));

    row.push(getVal('Eact'), getVal('Erea'), getVal('Eapp'));



    sheet.appendRow(row);



    return ContentService.createTextOutput(JSON.stringify({ status: 'success', message: 'Dato guardado correctamente.' }))

        .setMimeType(ContentService.MimeType.JSON);

  } catch (err) {

    return ContentService.createTextOutput(JSON.stringify({ status: 'error', error: err.toString() })).setMimeType(ContentService.MimeType.JSON);

  }

}



// ----------------- Lectura (Frontend) -----------------

function handleRead(e) {

  var ss = SpreadsheetApp.getActiveSpreadsheet();

  var sheet = ss.getSheetByName("LECTURAS PZEM");



  if (!sheet || sheet.getLastRow() < 2) {

    return jsonResponse({ status: 'error', error: 'No hay datos en la hoja.' });

  }



  var mode = (e.parameter.mode || 'realtime');



  // Mapa de índices 0-based sobre el array row obtenido de getValues()

  var map = {

    'Va': 1, 'Vb': 2, 'Vc': 3,

    'Ia': 4, 'Ib': 5, 'Ic': 6,

    'Fa': 7, 'Fb': 8, 'Fc': 9,

    'Pa': 10, 'Pb': 11, 'Pc': 12,

    'Qa': 13, 'Qb': 14, 'Qc': 15,

    'Sa': 16, 'Sb': 17, 'Sc': 18,

    'FPa': 19, 'FPb': 20, 'FPc': 21,

    'Pt': 22, 'Qt': 23, 'St': 24,

    'E_Pt': 26, 'E_Qt': 27, 'E_St': 28

  };



  if (mode === 'realtime') {

    return handleRealTimeRead(sheet, map, e.parameter.colsToQuery);

  } else if (mode === 'historical' && e.parameter.start && e.parameter.end) {

    return handleHistoricalRead(sheet, map, e.parameter.colsToQuery, e.parameter.start, e.parameter.end);

  } else {

    return jsonResponse({ status: 'error', error: 'Modo de lectura no válido o parámetros de fecha faltantes.' });

  }

}



function handleRealTimeRead(sheet, map, colsToQuery) {

  try {

    var lastRowIdx = sheet.getLastRow();

    var data = sheet.getRange(lastRowIdx, 1, 1, sheet.getLastColumn()).getValues()[0];

    var requestedKeys = colsToQuery.split(',');

    var responseData = {};



    requestedKeys.forEach(function(key){

      var val = processDataPoint(key, data, map);

      if (val !== undefined) responseData[key] = val;

    });



    return jsonResponse({ status: 'success', lastRow: lastRowIdx, data: responseData });

  } catch (err) {

    return jsonResponse({ status: 'error', error: err.toString() });

  }

}



function handleHistoricalRead(sheet, map, colsToQuery, startDateStr, endDateStr) {

  try {

    var ssTimeZone = SpreadsheetApp.getActive().getSpreadsheetTimeZone();



    // ------ MODIFICACIÓN Aquí: INCLUYE segundos en formato ------

    var startDate = Utilities.parseDate(startDateStr, ssTimeZone, "yyyy-MM-dd'T'HH:mm:ss");

    var endDate = Utilities.parseDate(endDateStr, ssTimeZone, "yyyy-MM-dd'T'HH:mm:ss");

    // ------------------------------------------------------------



    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {

      return jsonResponse({ status: 'error', error: 'Formato de fecha/hora inválido.' });

    }



    var values = sheet.getDataRange().getValues();

    var rawData = values.slice(1); // excluir header

    var requestedKeys = colsToQuery.split(',');

    var historicalData = [];



    rawData.forEach(function(row) {

      var timestamp = row[0]; // columna A

      if (timestamp instanceof Date && timestamp >= startDate && timestamp <= endDate) {

        var rowObject = {};

        rowObject['Timestamp'] = Utilities.formatDate(timestamp, ssTimeZone, "dd/MM HH:mm");

        requestedKeys.forEach(function(key) {

          var val = processDataPoint(key, row, map);

          if (val !== undefined) rowObject[key] = val;

        });

        historicalData.push(rowObject);

      }

    });



    return jsonResponse({ status: 'success', data: historicalData });

  } catch (err) {

    return jsonResponse({ status: 'error', error: err.toString() });

  }

}



function processDataPoint(key, rowData, map) {

  if (map[key] !== undefined) {

    return rowData[map[key]];

  } else if (key === 'Vab') {

    return (rowData[1] !== undefined && rowData[1] !== '' ) ? rowData[1] * Math.sqrt(3) : null;

  } else if (key === 'Vbc') {

    return (rowData[2] !== undefined && rowData[2] !== '' ) ? rowData[2] * Math.sqrt(3) : null;

  } else if (key === 'Vca') {

    return (rowData[3] !== undefined && rowData[3] !== '' ) ? rowData[3] * Math.sqrt(3) : null;

  }

  return undefined;

}



function jsonResponse(obj) {

  return ContentService.createTextOutput(JSON.stringify(obj)).setMimeType(ContentService.MimeType.JSON);

}
